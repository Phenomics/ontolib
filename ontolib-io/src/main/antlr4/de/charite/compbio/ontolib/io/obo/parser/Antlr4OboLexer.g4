/** ANTLR 4 lexer for the OBO v1.2 ontology description format.
 *
 * See <a href="http://owlcollab.github.io/oboformat/doc/GO.format.obo-1_2.html">The OBO Flat File
 * Format Specification, version 1.2 </a> for details.
 *
 * @author <a href="mailto:manuel.holtgrewe@bihealth.de">Manuel Holtgrewe</a>
 */
lexer grammar Antlr4OboLexer;

// Default Mode ================================================================
//
// These rules capture the stanza headers and the key part of the key/value
// pairs.

// Stanza Headers

TermStanzaHeader
:
  '[Term]'
;

TypedefStanzaHeader
:
  '[Typedef]'
;

InstanceStanzaHeader
:
  '[Instance]'
;

// Stanza tags

TagID
:
  'id'
;

TagName
:
  'name'
;

TagIsAnonymous
:
  'is_anonymous'
;

TagAltId
:
  'alt_id'
;

TagDef
:
  'def'
;

TagComment
:
  'comment'
;

TagSubset
:
  'subset'
;

TagSynonym
:
  'synonym'
;

TagXref
:
  'xref'
;

TagIsA
:
  'is_a'
;

TagIntersectionOf
:
  'intersection_of'
;

TagUnionOf
:
  'union_of'
;

TagDisjointFrom
:
  'disjoint_from'
;

TagRelationship
:
  'relationship'
;

TagIsObsolete
:
  'is_obsolete'
;

TagReplacedBy
:
  'replaced_by'
;

TagConsider
:
  'consider'
;

TagCreatedBy
:
  'created_by'
;

TagCreationDate
:
  'creation_date'
;

TagDomain
:
  'domain'
;

TagRange
:
  'range'
;

TagInverseOf
:
  'inverse_of'
;

TagTransitiveOver
:
  'transitive_over'
;

TagIsCyclic
:
  'is_cyclic'
;

TagIsReflexive
:
  'is_reflexive'
;

TagIsSymmetric
:
  'is_symmetric'
;

TagIsAntisymmetric
:
  'is_antisymmetric'
;

TagIsTransitive
:
  'is_transitive'
;

TagIsMetadata
:
  'is_metadata'
;

TagInstanceOf
:
  'instance_of'
;

TagFormatVersion
:
  'format-version'
;

TagVersion
:
  'version'
;

TagDataVersion
:
  'data-version'
;

TagDate
:
  'date'
;

TagSavedBy
:
  'saved-by'
;

TagAutoGeneratedBy
:
  'auto-generated-by'
;

TagSubsetdef
:
  'subsetdef'
;

TagImport
:
  'import'
;

TagSynonymtypedef
:
  'synonymtypedef'
;

TagIdspace
:
  'idspace'
;

TagDefaultRelationshipIdPrefix
:
  'default-relationship-id-prefix'
;

TagIdMapping
:
  'id-mapping'
;

TagRemark
:
  'remark'
;

GenericStanzaTag
:
  (
    ESC
    | [-_a-zA-Z]
  )+
;

// Escaped characters in default mode

ESC
:
  '\\' [nWt:,"[\]{}]
;

// Comments in default mode (and spaces before them)

Comment
:
  Space* '!' ~[\r\n]*
;

// Colon
//
// Hitting a colon in default mode switches over to the value mode

ColonSpace
:
  ':' ' '+ -> pushMode ( valueMode )
;

// End-of line pulls in the space

Eol
:
  ' '* LineBreak
;

// Platform-agnostic line break

fragment
LineBreak
:
  '\r'? '\n'
;

// Value Mode ==================================================================
//
// Rules in this mode behave differently in that they can assume that we are
// right of the colon.
mode valueMode;

// Boolean values

BooleanValue
:
  (
    'true'
    | 'false'
  )
;

// Scope identifier

ScopeIdentifier
:
  'EXACT'
  | 'BROAD'
  | 'NARROW'
  | 'RELATED'
;

// Braces

CurlyBraceOpen
:
  '{'
;

CurlyBraceClose
:
  '}'
;

SquareBraceOpen
:
  '['
;

SquareBraceClose
:
  ']'
;

// Equals sign

Equals
:
  '='
;

// Comma

Comma
:
  ','
;

// Semicolon

Semicolon
:
  ';'
;

// Space

Space
:
  ' '
;

// A string without any space or non-alphanumeric character with special meaning

Word
:
  (
    Esc2
    | ~[ \r\n[\]{},="]
  )+
;

// Quoted string value

QuotedString
:
  '"'
  (
    Esc2
    | ~[\\"\r\n]
  )*? '"'
;

// End-of line pulls in the space

Eol2
:
  ' '* LineBreak2 -> popMode
;

// Platform-agnostic line break

fragment
LineBreak2
:
  '\r'? '\n'
;

// Comments (and spaces before them)

Comment2
:
  Space* '!' ~[\r\n]*
;

// Escaped characters in value mode

Esc2
:
  '\\' [nWt,"[\]{}]
;

// Move errors from the lexer to the parser

ErrorChar
:
  .
;
